// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract AutoServiceToken is ERC20, Ownable {
struct Service {
  uint256 serviceId;
  uint256 price;
  string serviceName;
  uint256 durationDays;}
    constructor() ERC20("Saalonga", "ATS") Ownable(msg.sender) {        initializeServices();}
    function initializeServices() internal {
        serviceRegistry[1] = Service(1, 1000, "Carburetor Cleaning", 1);serviceRegistry[2] = Service(2, 4500, "Fuel Injection Cleaning", 2);
        serviceRegistry[3] = Service(3, 5200, "Gas Tank Cleaning", 3);serviceRegistry[4] = Service(4, 5250, "Suspension Repair", 4);
        serviceRegistry[5] = Service(5, 1080, "Oil Change", 1);serviceRegistry[6] = Service(6, 1600, "Brake Repair", 1);
        serviceRegistry[7] = Service(7, 8000, "Transmission Repair", 5);serviceRegistry[8] = Service(8, 1000, "Tuning", 1);
        serviceRegistry[9] = Service(9, 10000, "Top Overhaul", 6);serviceRegistry[10] = Service(10, 35000, "Complete Overhaul", 7);
        serviceRegistry[11] = Service(11, 5200, "Radiator Repair", 2);serviceRegistry[12] = Service(12, 15300, "Turbo Installation", 3);
        serviceRegistry[13] = Service(13, 5400, "Joint Grease Repacking", 1); } 
    function decimals() public pure override returns (uint8) {
        return 0;}
    function issueTokens(address recipient, uint256 amount) external onlyOwner {
        _mint(recipient, amount);
        emit TokensIssued(recipient, amount);}
    function buyService(uint256 serviceId) external {
        require(serviceRegistry[serviceId].price > 0, "Service does not exist.");
        require(balanceOf(msg.sender) >= serviceRegistry[serviceId].price, "Not enough tokens.");
        _burn(msg.sender, serviceRegistry[serviceId].price);
        userServiceRecords[msg.sender][serviceId] += 1;
        emit ServicePurchased(msg.sender, serviceId, serviceRegistry[serviceId].price);}
    function removeTokens(uint256 amount) external {
        require(balanceOf(msg.sender) >= amount, "Not enough tokens.");
        _burn(msg.sender, amount);
        emit TokensRemoved(msg.sender, amount);}
    function activateService(uint256 serviceId) external {
        require(userServiceRecords[msg.sender][serviceId] > 0, "Service not owned.");
        userServiceRecords[msg.sender][serviceId] -= 1;
        uint256 expirationTime = block.timestamp + (serviceRegistry[serviceId].durationDays * 1 days);
        serviceExpiration[msg.sender][serviceId] = expirationTime;
        utilizedServices[msg.sender].push(serviceId);
        emit ServiceActivated(msg.sender, serviceId, serviceRegistry[serviceId].serviceName, expirationTime);}
    function addService(uint256 id, uint256 price, string memory name, uint256 durationDays) external onlyOwner {
        require(serviceRegistry[id].price == 0, "Service already exists.");
        serviceRegistry[id] = Service(id, price, name, durationDays);}
    function viewBalance() external view returns (uint256) {
        return balanceOf(msg.sender);}
    function getServiceDescription(uint256 serviceId) external view returns (string memory) {
    require(serviceId >= 1 && serviceId <= 13, "Service ID out of range");
    Service memory service = serviceRegistry[serviceId]; string memory description = string(abi.encodePacked(
        "Service ID: ", uintToString(service.serviceId), "\n",
        "Service Name: ", service.serviceName, "\n",
        "Price: ", uintToString(service.price), " ATS\n",
        "Duration: ", uintToString(service.durationDays), " days\n"));return description;}
    function viewUserServices() external view returns (string memory) {
        string memory userServices = "Your Services:\n";
        for (uint256 i = 1; i <= 13; i++) {
            userServices = string(abi.encodePacked(
                userServices, serviceRegistry[i].serviceName, " (", uintToString(userServiceRecords[msg.sender][i]), ")\n"));}return userServices;}
    function viewActivatedServices() external view returns (string memory) {
        string memory activatedServices = "Activated Services:\n";
        for (uint256 i = 0; i < utilizedServices[msg.sender].length; i++) {
            uint256 serviceId = utilizedServices[msg.sender][i];
            activatedServices = string(abi.encodePacked(
                activatedServices, serviceRegistry[serviceId].serviceName, " (Expires: ", uintToString(serviceExpiration[msg.sender][serviceId]), ")\n" ));}return activatedServices;}
    function uintToString(uint256 value) internal pure returns (string memory) {
        if (value == 0) {
            return "0"; }
        uint256 maxLength = 78;
        bytes memory reversed = new bytes(maxLength);
        uint256 i = 0;
        while (value != 0) {
            uint256 remainder = value % 10;
            value /= 10;
            reversed[i++] = bytes1(uint8(48 + remainder));}
        bytes memory s = new bytes(i);
        for (uint256 j = 0; j < i; j++) {
            s[j] = reversed[i - j - 1];
        }return string(s);}
    event TokensIssued(address indexed beneficiary, uint256 amount);
    event ServicePurchased(address indexed client, uint256 serviceId, uint256 price);
    event TokensRemoved(address indexed account, uint256 amount);
    event ServiceActivated(address indexed user, uint256 serviceId, string serviceName, uint256 expirationTime);
    mapping(uint256 => Service) private serviceRegistry;
    mapping(address => mapping(uint256 => uint256)) private userServiceRecords;
    mapping(address => uint256[]) private utilizedServices;
    mapping(address => mapping(uint256 => uint256)) private serviceExpiration;
}
